# Архитектурные решения (Architecture Decision Records)

## 1. Чистый PHP без фреймворка

**Решение:** Приложение реализовано на чистом PHP 8.3 с минимальным набором библиотек (FastRoute, BladeOne, phpdotenv).

**Причина:** Масштаб проекта не оправдывает использование полноценного фреймворка (Laravel, Symfony). Приложение содержит ~15 сервисов и 4 контроллера — накладные расходы фреймворка превысили бы пользу. Минимальный набор библиотек даёт фреймворко-подобный DX при минимальном overhead.

**Альтернативы:** Laravel (избыточен для данного масштаба), Slim Framework (возможный вариант, но не даёт значительного преимущества).

---

## 2. SELECT FOR UPDATE для защиты от гонки

**Решение:** Конкурентная безопасность операции «Взять в работу» реализована через `SELECT ... FOR UPDATE` внутри MySQL-транзакции.

**Причина:** Блокировка строки на уровне InnoDB — самое надёжное решение, т.к. данные и блокировка живут в одном хранилище (MySQL). Нет необходимости координировать два хранилища. Семантика `SELECT FOR UPDATE` хорошо документирована и предсказуема.

**Альтернативы рассмотрены:**
- Оптимистичная блокировка (version column) — сложнее в реализации, требует повторных попыток на уровне приложения.
- Redis distributed lock (SETNX) — добавляет зависимость от Redis для критического пути; данные в MySQL, а блокировка в Redis = рассинхронизация при падении Redis.

---

## 3. State Machine как отдельный Domain-класс

**Решение:** Логика переходов статусов вынесена в `RequestStateMachine` — чистый доменный класс без инфраструктурных зависимостей.

**Причина:** Single Responsibility Principle — один класс отвечает за правила переходов. Контроллеры, сервисы и тесты используют один источник истины. Добавление новых статусов или переходов требует изменения только одного класса. Класс тривиально тестируется без моков и баз данных.

---

## 4. Service Layer как граница транзакций

**Решение:** Транзакции БД открываются и закрываются в методах `RequestService`, а не в контроллерах или репозиториях.

**Причина:** Сервисный слой оркестрирует несколько вызовов репозиториев и доменных валидаций в рамках одной атомарной операции. Транзакции в контроллерах смешали бы HTTP-логику с консистентностью данных. Транзакции в репозиториях сделали бы невозможными атомарные мульти-репозиторные операции.

---

## 5. Аудит-лог в отдельной таблице

**Решение:** История изменений статусов хранится в таблице `audit_log` с FK-связями на `repair_requests` и `users`.

**Причина:** Реляционное хранилище позволяет эффективные запросы («показать все изменения заявки #42», «все действия мастера Петрова»). Поддерживает ссылочную целостность.

**Альтернативы рассмотрены:**
- JSON-колонка в таблице заявки — плохая производительность запросов, нет индексации.
- Файловые логи — нет реляционных запросов, сложно связать с сущностями.
- Redis Stream — недостаточная персистентность для audit trail.

---

## 6. BladeOne для шаблонизации

**Решение:** Используется `eftec/bladeone` — автономный порт Blade-синтаксиса без зависимости от Laravel.

**Причина:** Blade-синтаксис знаком PHP-разработчикам. BladeOne поддерживает layouts, sections, директивы, авто-экранирование — всё необходимое для проекта. Одна библиотека без транзитивных зависимостей.

**Альтернативы:** Twig (тяжелее, требует больше конфигурации), чистый PHP (нет авто-экранирования, нет наследования шаблонов).

---

## 7. Простой DI-контейнер вместо библиотеки

**Решение:** Реализован минималистичный DI-контейнер (~50 строк) с методами `bind()`, `singleton()`, `get()`.

**Причина:** Приложение содержит ~15 сервисов. Полноценный DI-контейнер (PHP-DI, Symfony DI) добавил бы ещё одну Composer-зависимость при минимальной пользе для данного масштаба. Ручной контейнер с singleton-поддержкой и фабриками покрывает все потребности.

**Ограничения:** Не поддерживает автовайринг, интерфейс-биндинг, conditional binding. Для данного проекта это не требуется.
